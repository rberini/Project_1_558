---
title: "ST 558 Project One"
author: "Robert Berini & Robert Ferrand"
format: html
editor: visual
---

## Project Overview

some placeholder text

## Required Packages

Load required packages for project

library(tidyverse)

library(httr)

library(jsonlite)

library(tidycensus)

```{r}
library(tidyverse)
library(httr)
library(jsonlite)
library(tidycensus)
library(janitor)
library(quantreg)
```

## Data Processing

some placeholder text

```{r}
valid_num_var <- c("AGEP", "GASP", "GRPIP", "JWAP", "JWDP", "JWMNP", "PWGTP")
valid_cat_var <- c("FER", "HHL", "HISPEED", "JWAP", "JWDP", "JWTRNS", "SCH", "SCHL", "SEX")
valid_geo_level <- c("All", "Region", "Division", "State")

URL_base <- "https://api.census.gov/data/"

numeric_select <- 

#URL_id = paste0(URL_base,year_select,"/acs/acs1/pums?get=PWGTP,",numeric_select,",",cat_select)

#URL_id <- "https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP&SCHL=24"
URL_id <- "https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,RAC1P&AGEP=30&for=division:9"

census_df <- fromJSON(URL_id)

census_tib <- census_df |>
  as_tibble() |>
  row_to_names(row_number = 1)


for (column in colnames(census_tib)){
  if (column %in% valid_num_var) {
    census_tib[[column]] <- as.numeric(census_tib[[column]])
  } else if (column %in% valid_cat_var) {
    census_tib[[column]] <- as.factor(census_tib[[column]])
  }
}
```

THIS ONE WORKS

```{r}
surv_year <- c(2010:2022)
valid_num_var <- c("AGEP", "GASP", "GRPIP", "JWAP", "JWDP", "JWMNP", "PWGTP")
valid_cat_var <- c("FER", "HHL", "HISPEED", "JWAP", "JWDP", "JWTRNS", "SCH", "SCHL", "SEX")
valid_geo_level <- c("ALL", "REGION", "DIVISION", "STATE")

api_query <- function(surv_year = "2022", num_var = c("AGEP"), cat_var = "SEX", geo_level = "All", condition = NULL, geo_subset = NULL)
{
   if (surv_year < 2010 || surv_year > 2022) {
    stop("Year must be between 2010 and 2022.")
   }
  if (any(!num_var %in% valid_num_var)) {
    stop("Invalid Numeric Variable")
    }
  if (any(!cat_var %in% valid_cat_var)) {
        stop("Invalid Categorical Variable")
  }
    if (any(!geo_level %in% valid_geo_level)) {
        stop("Invalid Geography Level")
    }
  
  num_var_string <- paste(unique(num_var), collapse = ",")
  cat_var_string <- paste(unique(cat_var), collapse = ",")
  geo_level_string <- paste(unique(geo_level), collapse = ",")
  URL_base <- "https://api.census.gov/data/"
  URL_id <- paste0(URL_base, surv_year, "/acs/acs1/pums?get=PWGTP,", num_var_string, ",", cat_var_string, ",",geo_level_string)
  
  
  if (!is.null(condition)) {
    condition_string <- paste(condition, collapse = "&")
    URL_id <- paste0(URL_id, "&", condition_string)
  }
  
  print("THIS IS AN ERROR ILL FIX IT LATER")
  if(!is.null(geo_subset)) {
    print(geo_subset)
    region_string <- paste(geo_subset, collapse = "&")
    print(region_string)
    URL_id <- paste0(URL_id, "&for=", region_string)
    print(URL_id)
  }

  
  #AS DATETIME, AS DATE, AS TIME
  
  #parsed_url <- parse_url(URL_id)
  #query_params <- parsed_url$query
  #params <- unlist(strsplit(query_params$get, ","))
  #params <- params[!params %in% names(query_params)]
  #query_params$get <- paste(rev(unique(rev(params))), collapse = ",")
  #final_url <- build_url(parsed_url)
  #final_url <- gsub("%2C", ",", cleaned_url)
  #URL_id <- final_url
  
  parsed_url <- parse_url(URL_id)
  print(parsed_url)
    parsed_url$query$get <- paste(unique(unlist(strsplit(parsed_url$query$get, ",")))[!unique(unlist(strsplit(parsed_url$query$get, ","))) %in% names(parsed_url$query)], collapse = ",")
  URL_id <- gsub("%2C", ",", build_url(parsed_url))
  print(URL_id)


  
  census_df <- fromJSON(URL_id)
  
  census_tib <- census_df |>
    as_tibble() |>
    row_to_names(row_number = 1)
  
  
  for (column in colnames(census_tib)) {
    if (column %in% valid_num_var) {
      census_tib[[column]] <- as.numeric(census_tib[[column]])
    } else if (column %in% valid_cat_var) {
      census_tib[[column]] <- as.factor(census_tib[[column]])
    }
  }
  print(census_tib)
}



#make it so that you can't print two of the same column name
#create a for loop to specify multiple data items
```

## Obtaining Person Level Records

some placeholder text

```{r}

```

## Writing a Generic Function for Summarizing

some placeholder text

### Numeric Summary

write a function that produces means and standard deviations for our numeric variable(s) and counts for our categorical variable(s).

```{r}

```

Test out this function by running summary(*your_census_tibble*) on something you've returned from your census API function.

```{r}

```

### Graphical Summary

Similarly, let's create a generic plot() function for a census class tibble. Require the user to specify one categorical variable and one numeric variable for plotting purposes.

```{r}

#ggplot(your_census_tibble, aes(x = get(cat_var), y = get(num_var), weight = PWGTP)) + geom_boxplot()
```
