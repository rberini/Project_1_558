---
title: "ST 558 Project One"
author: "Robert Berini & Robert Ferrand"
format: html
editor: visual
---

## Project Overview

Our goal is to write functions that will manipulate and process data sets that come from a census API. Query the Public Use Microdata Sample (PUMS) Census API. Create a function that allows the user to call the API with different combinations of variables. Provide numerical and graphical summaries. We’ll create generic functions to automatically summarize and plot certain returned data. Lastly, we’ll write up a document via quarto to describe our thought process and give examples of using the functions.

## Required Packages

Load required packages for project

```{r setup, message=FALSE, warning=FALSE}
library(tidyverse)
library(httr)
library(jsonlite)
library(janitor)
library(quantreg)
library(roxygen2)
```

## Data Processing

some placeholder text

### Build API

Creating median time table for JWAP and JWDP

*Note to Robbie: We'll have to call these from the functions and write a join*

JWAP

```{r}
URL_jwap <- "https://api.census.gov/data/2022/acs/acs1/pums/variables/JWAP.json"
jwap_time_table <- GET(URL_jwap)

jwap_time_table <- fromJSON(rawToChar(jwap_time_table$content))
jwap_time_table <- as_tibble(jwap_time_table$values$item)
jwap_time_table <- pivot_longer(jwap_time_table,
                         cols = 1:ncol(jwap_time_table),
                         names_to = "code",
                         values_to = "range") |>
  filter(code != 0) |>
  separate_wider_delim(range, delim = " ", names = c("time1", "AMPM1", "to", "time2", "AMPM2")) 

jwap_time_table <- jwap_time_table |>
  mutate(median_time = if_else(
    AMPM1 == "a.m.",
    hms::as_hms(
    hms::parse_hm(jwap_time_table$time1) +
      ((hms::parse_hm(jwap_time_table$time2) -
          hms::parse_hm(jwap_time_table$time1)) / 2)),
     hms::as_hms(hms::parse_hm("12:00") +
                   hms::parse_hm(jwap_time_table$time1) +
                   ((hms::parse_hm(jwap_time_table$time2) -
                       hms::parse_hm(jwap_time_table$time1)) / 2)))) |>
  mutate(median_time = if_else(median_time > hms::as_hms("12:00:00") &
                                 median_time < hms::as_hms("12:59:59") &
                                 AMPM1 == "a.m.",
                               median_time - hms::as_hms("12:00:00"),
                               median_time)) |>
  select(code, median_time) |>
  arrange(median_time) |>
  add_row(code = "0", median_time = hms::as_hms(NA))

jwap_time_table$code <- as.numeric(jwap_time_table$code)

jwap_time_table
```

JWDP

```{r}
URL_jwdp <- "https://api.census.gov/data/2022/acs/acs1/pums/variables/JWDP.json"
jwdp_time_table <- GET(URL_jwdp)

jwdp_time_table <- fromJSON(rawToChar(jwdp_time_table$content))
jwdp_time_table <- as_tibble(jwdp_time_table$values$item)
jwdp_time_table <- pivot_longer(jwdp_time_table,
                         cols = 1:ncol(jwdp_time_table),
                         names_to = "code",
                         values_to = "range") |>
  filter(code != 0) |>
  separate_wider_delim(range, delim = " ", names = c("time1", "AMPM1", "to", "time2", "AMPM2")) 

jwdp_time_table <- jwdp_time_table |>
  mutate(median_time = if_else(
    AMPM1 == "a.m.",
    hms::as_hms(
    hms::parse_hm(jwdp_time_table$time1) +
      ((hms::parse_hm(jwdp_time_table$time2) -
          hms::parse_hm(jwdp_time_table$time1)) / 2)),
     hms::as_hms(hms::parse_hm("12:00") +
                   hms::parse_hm(jwdp_time_table$time1) +
                   ((hms::parse_hm(jwdp_time_table$time2) -
                       hms::parse_hm(jwdp_time_table$time1)) / 2)))) |>
  mutate(median_time = if_else(median_time > hms::as_hms("12:00:00") &
                                 median_time < hms::as_hms("12:59:59") &
                                 AMPM1 == "a.m.",
                               median_time - hms::as_hms("12:00:00"),
                               median_time)) |>
  select(code, median_time) |>
  arrange(median_time) |>
  add_row(code = "0", median_time = hms::as_hms(NA))

jwdp_time_table$code <- as.numeric(jwdp_time_table$code)

jwdp_time_table
```

Creating the API function

```{r}

#' setup global variables to be returned
#' @noRd

census_tib <- as_tibble(data.frame())
num_var <- ""
cat_var <- ""

#' Begin query building
#' Numeric variable PWGTP is required for function and always called so is not included as a default that can be overwritten
#' @noRd

api_query <- function(surv_year = "2022", num_var = "AGEP", cat_var = "SEX", geo_level = "All", geo_code = "*", condition = NULL) {

  #numeric variable PWGTP is required for function and always called
  valid_num_var <- c("AGEP", "GASP", "GRPIP", "JWAP", "JWDP", "JWMNP")
  valid_date_var <- c("JWAP", "JWDP")
  valid_cat_var <- c("FER", "HHL", "HISPEED", "JWTRNS", "SCH", "SCHL", "SEX")
  valid_geo_level <- c("All", "Region", "Division", "State")
  
  #ensure user selection is within permissible values
  if (surv_year < 2010 || surv_year > 2022) {
    stop("Year must be between 2010 and 2022.")
   }
  if (any(!num_var %in% valid_num_var)) {
    stop("Invalid Numeric Variable")
    }
  if (any(!cat_var %in% valid_cat_var)) {
    stop("Invalid Categorical Variable")
  }
  if (any(!geo_level %in% valid_geo_level)) {
    stop("Invalid Geography Level")
    }
  
  #create url string
  num_var_string <- paste(num_var, collapse = ",")
  print(num_var_string) #display num_var selection while executing
  cat_var_string <- paste(cat_var, collapse = ",")
  print(cat_var_string) #display cat_var selection while executing
  URL_base <- "https://api.census.gov/data/"
  #construct api url to be called; PWGTP is required and always included in call
  URL_id <- paste0(URL_base, surv_year, "/acs/acs1/pums?get=PWGTP,", num_var_string, ",", cat_var_string)
  
  if(geo_level != "All") {
    geo_level <- tolower(geo_level)
    URL_id <- paste0(URL_id, "&for=", geo_level, ":", geo_code)
  }
  
  if (!is.null(condition)) {
    condition_string <- paste(condition, collapse = "&")
    URL_id <- paste0(URL_id, "&", condition_string)
  }
  
  #display api url called for confirmtion
  print(URL_id)
  
  #call API and create database
  census_info <- GET(URL_id)
  
  census_df <- fromJSON(rawToChar(census_info$content))
  
  census_tib <- census_df |>
    as_tibble() |>
    row_to_names(row_number = 1)
  
  census_tib$PWGTP <- as.numeric(census_tib$PWGTP)
  
  for (column in colnames(census_tib)) {
    if (column %in% valid_date_var) {
      census_tib[[column]] <- as.numeric(census_tib[[column]])
    } else if (column %in% valid_num_var) {
      census_tib[[column]] <- as.numeric(census_tib[[column]])
    } else if (column %in% valid_cat_var) {
      census_tib[[column]] <- as.factor(census_tib[[column]])
    }
  }
  
  if(str_detect(URL_id,"JWAP")) {
    census_tib <- census_tib |>
      left_join(
        jwap_time_table,
        by = c("JWAP" = "code")
        ) |>
      select(-JWAP) |>
      rename(JWAP = median_time)
    }
  
  if(str_detect(URL_id,"JWDP")) {
    census_tib <- census_tib |>
      left_join(
        jwap_time_table,
        by = c("JWDP" = "code")
        ) |>
      select(-JWDP) |>
      rename(JWDP = median_time)
    }
  
  #' Function for creating data assigns a class of census to resulting tibble
  #' @noRd
  
  class(census_tib) <- c("census", class(census_tib))
  
  #' Ensure resulting tibble (census_tib) and selected variables are returned to the global environment for use in other functions and analysis
  #' Superassigmment operator (<<-) is intentional to ensure local variables are passed to the global environment
  #' A list including num_var, cat_var and census_tib is returned for redudancy and convenience so user assign function to an object and then specify the corresponding version of the variable created
  #' @noRd
  
  num_var <<- num_var
  cat_var <<- cat_var
  census_tib <<- census_tib
  
  return(list(
    num_var = num_var,
    cat_var = cat_var,
    census_tib = census_tib
  ))
}


#make it so that you can't print two of the same column name
#make it so that geography level does something, condition it?
#create a for loop to specify multiple data items
```

### Obtaining Person Level Records

The `PWGTP` variable actually represents the number of (people) observations there should be for a particular row.

### Test the API Function

Run various combinations of inputs (including default) to test function

```{r}
default_query <- api_query()
default_query

```

```{r}
api_query(2016, num_var = c("GASP", "GRPIP", "JWAP"), "FER")
```

```{r}
default_nc <- api_query(geo_level = "State", geo_code = "37")
default_nc
```

```{r}
default_masters_nc <- api_query(
  geo_level = "State",
  geo_code = "37",
  condition = "SCHL=22"
  )
default_masters_nc
```

Final run to reflect assigned `state`: 11 / DC

```{r}
default_dc <- api_query(
    geo_level = "State",
    geo_code = "11"
)
default_dc
```

## Writing a Generic Function for Summarizing

some placeholder text

### Numeric Summary

write a function that produces means and standard deviations for our numeric variable(s) and counts for our categorical variable(s).

```{r}
census_summary <- function(tib = census_tib, cat_var, num_var) {
  sample_mean <- sum(tib[[num_var]] * tib$PWGTP)/sum(tib$PWGTP)
  sample_sd <- sqrt(sum((tib[[num_var]]^2)*tib$PWGTP)/sum(tib$PWGTP)-sample_mean^2)
  
  counts <- tib |>
    group_by(tib[[cat_var]]) |>
    summarise(n = n())

  return(list(sample_mean = sample_mean, sample_sd = sample_sd, counts = counts))
}
```

Test out this function by running summary (*your_census_tibble*) on something you’ve returned from your census API function.

```{r}
cen_sum <- census_summary(cat_var = "SEX", num_var = "AGEP")
print(cen_sum)
```

### Graphical Summary

Similarly, let’s create a generic `plot()` function for a census class tibble. Require the user to specify one categorical variable and one numeric variable for plotting purposes.

```{r}

census_plot <- function() {
  ggplot(census_tib,
       aes(x = .data[[cat_var]], y = .data[[num_var]], weight = PWGTP)) +
    geom_boxplot()
}
```

Test `census_plot` function

```{r}

census_plot()
```
