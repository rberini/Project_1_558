[
  {
    "objectID": "project_1_558.html",
    "href": "project_1_558.html",
    "title": "ST 558 Project One",
    "section": "",
    "text": "Query the Public Use Microdata Sample (PUMS) Census API. Creates a function that allows the user to call the API with different combinations of variables. Provides numerical and graphical summaries.Our goal is to write functions that will manipulate and process data sets that come from a census API. We’ll create generic functions to automatically summarize and plot certain returned data. Lastly, we’ll write up a document via quarto to describe our thought process and give examples of using the functions."
  },
  {
    "objectID": "project_1_558.html#project-overview",
    "href": "project_1_558.html#project-overview",
    "title": "ST 558 Project One",
    "section": "",
    "text": "Query the Public Use Microdata Sample (PUMS) Census API. Creates a function that allows the user to call the API with different combinations of variables. Provides numerical and graphical summaries.Our goal is to write functions that will manipulate and process data sets that come from a census API. We’ll create generic functions to automatically summarize and plot certain returned data. Lastly, we’ll write up a document via quarto to describe our thought process and give examples of using the functions."
  },
  {
    "objectID": "project_1_558.html#required-packages",
    "href": "project_1_558.html#required-packages",
    "title": "ST 558 Project One",
    "section": "Required Packages",
    "text": "Required Packages\nLoad required packages for project\n\nlibrary(tidyverse)\nlibrary(httr)\nlibrary(jsonlite)\nlibrary(tidycensus)\nlibrary(janitor)\nlibrary(quantreg)"
  },
  {
    "objectID": "project_1_558.html#data-processing",
    "href": "project_1_558.html#data-processing",
    "title": "ST 558 Project One",
    "section": "Data Processing",
    "text": "Data Processing\nsome placeholder text\n\nBuild API\nCreating median time table for JWAP and JWDP\nNote to Robbie: I’m not actually using this in the function yet. Just trying to figure out how to calculate the median time per range and retain the factor code. We’ll have to build this within the main function and write a lookup and replace routine\nJWDP\n\nURL_time &lt;- \"https://api.census.gov/data/2022/acs/acs1/pums/variables/JWDP.json\"\njwdp_data &lt;- GET(URL_time)\n\njwdp_time_data_2 &lt;- fromJSON(rawToChar(jwdp_data$content))\njwdp_time_data_3 &lt;- as_tibble(jwdp_time_data_2$values$item)\njwdp_time_table &lt;- pivot_longer(jwdp_time_data_3,\n                         cols = 1:ncol(jwdp_time_data_3),\n                         names_to = \"code\",\n                         values_to = \"range\") |&gt;\n  filter(code != 0) |&gt;\n  separate_wider_delim(range, delim = \" \", names = c(\"time1\", \"AMPM1\", \"to\", \"time2\", \"AMPM2\")) \n\njwdp_time_table &lt;- jwdp_time_table |&gt;\n  mutate(median_time = hms::as_hms(\n    hms::parse_hm(jwdp_time_table$time1) +\n      ((hms::parse_hm(jwdp_time_table$time2) - hms::parse_hm(jwdp_time_table$time1)) / 2))) |&gt;\n  select(code, median_time, everything()) |&gt;\n    arrange(code)\n\njwdp_time_table$code &lt;- as.numeric(jwdp_time_table$code)\n\njwdp_time_table\n\n# A tibble: 150 × 7\n    code median_time time1 AMPM1 to    time2 AMPM2\n   &lt;dbl&gt; &lt;time&gt;      &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1     1 12:14:30    12:00 a.m.  to    12:29 a.m. \n 2     2 12:44:30    12:30 a.m.  to    12:59 a.m. \n 3     3 01:14:30    1:00  a.m.  to    1:29  a.m. \n 4     4 01:44:30    1:30  a.m.  to    1:59  a.m. \n 5     5 02:14:30    2:00  a.m.  to    2:29  a.m. \n 6     6 02:44:30    2:30  a.m.  to    2:59  a.m. \n 7     7 03:04:30    3:00  a.m.  to    3:09  a.m. \n 8     8 03:14:30    3:10  a.m.  to    3:19  a.m. \n 9     9 03:24:30    3:20  a.m.  to    3:29  a.m. \n10    10 03:34:30    3:30  a.m.  to    3:39  a.m. \n# ℹ 140 more rows\n\n\nJWAP\n\nURL_time_2 &lt;- \"https://api.census.gov/data/2022/acs/acs1/pums/variables/JWAP.json\"\njwap_data &lt;- GET(URL_time_2)\n\njwap_time_data_2 &lt;- fromJSON(rawToChar(jwap_data$content))\njwap_time_data_3 &lt;- as_tibble(jwap_time_data_2$values$item)\njwap_time_table &lt;- pivot_longer(jwap_time_data_3,\n                         cols = 1:ncol(jwap_time_data_3),\n                         names_to = \"code\",\n                         values_to = \"range\") |&gt;\n  filter(code != 0) |&gt;\n  separate_wider_delim(range, delim = \" \", names = c(\"time1\", \"AMPM1\", \"to\", \"time2\", \"AMPM2\")) \n\njwap_time_table &lt;- jwap_time_table |&gt;\n  mutate(median_time = hms::as_hms(\n    hms::parse_hm(jwap_time_table$time1) +\n      ((hms::parse_hm(jwap_time_table$time2) - hms::parse_hm(jwap_time_table$time1)) / 2))) |&gt;\n  select(code, median_time, everything()) |&gt;\n  arrange(code)\n\njwap_time_table$code &lt;- as.numeric(jwap_time_table$code)\n\njwap_time_table\n\n# A tibble: 285 × 7\n    code median_time time1 AMPM1 to    time2 AMPM2\n   &lt;dbl&gt; &lt;time&gt;      &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1     1 12:02:00    12:00 a.m.  to    12:04 a.m. \n 2     2 12:07:00    12:05 a.m.  to    12:09 a.m. \n 3     3 12:12:00    12:10 a.m.  to    12:14 a.m. \n 4     4 12:17:00    12:15 a.m.  to    12:19 a.m. \n 5     5 12:22:00    12:20 a.m.  to    12:24 a.m. \n 6     6 12:27:00    12:25 a.m.  to    12:29 a.m. \n 7     7 12:34:30    12:30 a.m.  to    12:39 a.m. \n 8     8 12:42:00    12:40 a.m.  to    12:44 a.m. \n 9     9 12:47:00    12:45 a.m.  to    12:49 a.m. \n10    10 12:54:30    12:50 a.m.  to    12:59 a.m. \n# ℹ 275 more rows\n\n\nCreating the API function\n\nsurv_year &lt;- c(2010:2022)\nvalid_num_var &lt;- c(\"AGEP\", \"GASP\", \"GRPIP\", \"JWAP\", \"JWDP\", \"JWMNP\")\nvalid_date_var &lt;- c(\"JWAP\", \"JWDP\")\nvalid_cat_var &lt;- c(\"FER\", \"HHL\", \"HISPEED\", \"JWTRNS\", \"SCH\", \"SCHL\", \"SEX\")\nvalid_geo_level &lt;- c(\"All\", \"Region\", \"Division\", \"State\")\n\napi_query &lt;- function(surv_year = \"2022\", num_var = \"AGEP\", cat_var = \"SEX\", geo_level = \"All\", condition = NULL) {\n  if (surv_year &lt; 2010 || surv_year &gt; 2022) {\n    stop(\"Year must be between 2010 and 2022.\")\n   }\n  if (any(!num_var %in% valid_num_var)) {\n    stop(\"Invalid Numeric Variable\")\n    }\n  if (any(!cat_var %in% valid_cat_var)) {\n    stop(\"Invalid Categorical Variable\")\n  }\n  if (any(!geo_level %in% valid_geo_level)) {\n    stop(\"Invalid Geography Level\")\n    }\n  \n  num_var_string &lt;- paste(num_var, collapse = \",\")\n  print(num_var_string)\n  cat_var_string &lt;- paste(cat_var, collapse = \",\")\n  print(cat_var_string)\n  URL_base &lt;- \"https://api.census.gov/data/\"\n  URL_id &lt;- paste0(URL_base, surv_year, \"/acs/acs1/pums?get=PWGTP,\", num_var_string, \",\", cat_var_string)\n  \n  if (!is.null(condition)) {\n    condition_string &lt;- paste(condition, collapse = \"&\")\n    URL_id &lt;- paste0(URL_id, \"&\", condition_string)\n  }\n  \n  print(URL_id)\n  \n  \n  #call API and create database\n  \n  census_info &lt;- GET(URL_id)\n  \n  census_df &lt;- fromJSON(rawToChar(census_info$content))\n  \n  census_tib &lt;- census_df |&gt;\n    as_tibble() |&gt;\n    row_to_names(row_number = 1)\n  \n  census_tib$PWGTP &lt;- as.numeric(census_tib$PWGTP)\n  \n  for (column in colnames(census_tib)) {\n    if (column %in% valid_date_var) {\n      census_tib[[column]] &lt;- as.numeric(census_tib[[column]])\n    } else if (column %in% valid_num_var) {\n      census_tib[[column]] &lt;- as.numeric(census_tib[[column]])\n    } else if (column %in% valid_cat_var) {\n      census_tib[[column]] &lt;- as.factor(census_tib[[column]])\n    }\n  }\n  \n  # function for creating data should assign a class of census\n  \n  class(census_tib) &lt;- c(\"census\", class(census_tib))\n  \n  census_tib\n}\n\n\n\n#make it so that you can't print two of the same column name\n#make it so that geography level does something, condition it?\n#create a for loop to specify multiple data items\n\n\n\nObtaining Person Level Records\nThe PWGTP variable actually represents the number of (people) observations there should be for a particular row.\n\n\nTest the API Function\nRun various combinations of inputs (including default) to test function\n\napi_query()\n\n[1] \"AGEP\"\n[1] \"SEX\"\n[1] \"https://api.census.gov/data/2022/acs/acs1/pums?get=PWGTP,AGEP,SEX\"\n\n\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nℹ Using compatibility `.name_repair`.\n\n\n# A tibble: 3,373,378 × 3\n   PWGTP  AGEP SEX  \n   &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;\n 1     3    17 2    \n 2    42    73 1    \n 3    11    22 1    \n 4    32    82 2    \n 5    31    19 2    \n 6    32    88 1    \n 7    45    80 1    \n 8    37    33 1    \n 9    29    44 1    \n10    55    36 1    \n# ℹ 3,373,368 more rows\n\n\n\napi_query(2016, num_var = c(\"GASP\", \"GRPIP\"), \"FER\")\n\n[1] \"GASP,GRPIP\"\n[1] \"FER\"\n[1] \"https://api.census.gov/data/2016/acs/acs1/pums?get=PWGTP,GASP,GRPIP,FER\"\n\n\n# A tibble: 3,156,487 × 4\n   PWGTP  GASP GRPIP FER  \n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;\n 1    57   200     0 1    \n 2    65   200     0 0    \n 3    77   200     0 0    \n 4    76   200     0 0    \n 5    86   200     0 0    \n 6    54     3   101 0    \n 7    55     3     7 0    \n 8    96     2     0 0    \n 9   108     2     0 0    \n10    91     4     0 0    \n# ℹ 3,156,477 more rows\n\n\n\napi_query(2021, \"GASP\", \"HHL\")\n\n[1] \"GASP\"\n[1] \"HHL\"\n[1] \"https://api.census.gov/data/2021/acs/acs1/pums?get=PWGTP,GASP,HHL\"\n\n\n# A tibble: 3,252,599 × 3\n   PWGTP  GASP HHL  \n   &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;\n 1    35     3 0    \n 2    35     3 0    \n 3    70     3 0    \n 4   149     3 0    \n 5   177     3 0    \n 6    14     3 0    \n 7    14     3 0    \n 8    95     3 0    \n 9    31     3 0    \n10    27     3 0    \n# ℹ 3,252,589 more rows"
  },
  {
    "objectID": "project_1_558.html#writing-a-generic-function-for-summarizing",
    "href": "project_1_558.html#writing-a-generic-function-for-summarizing",
    "title": "ST 558 Project One",
    "section": "Writing a Generic Function for Summarizing",
    "text": "Writing a Generic Function for Summarizing\nsome placeholder text\n\nNumeric Summary\nwrite a function that produces means and standard deviations for our numeric variable(s) and counts for our categorical variable(s).\nTest out this function by running summary(your_census_tibble) on something you’ve returned from your census API function.\n\n\nGraphical Summary\nSimilarly, let’s create a generic plot() function for a census class tibble. Require the user to specify one categorical variable and one numeric variable for plotting purposes.\nTest census_plot function"
  }
]