[
  {
    "objectID": "project_1_558.html",
    "href": "project_1_558.html",
    "title": "ST 558 Project One",
    "section": "",
    "text": "Our goal is to write functions that will manipulate and process data sets that come from a census API. Query the Public Use Microdata Sample (PUMS) Census API. Create a function that allows the user to call the API with different combinations of variables. Provide numerical and graphical summaries. We’ll create generic functions to automatically summarize and plot certain returned data. Lastly, we’ll write up a document via quarto to describe our thought process and give examples of using the functions."
  },
  {
    "objectID": "project_1_558.html#project-overview",
    "href": "project_1_558.html#project-overview",
    "title": "ST 558 Project One",
    "section": "",
    "text": "Our goal is to write functions that will manipulate and process data sets that come from a census API. Query the Public Use Microdata Sample (PUMS) Census API. Create a function that allows the user to call the API with different combinations of variables. Provide numerical and graphical summaries. We’ll create generic functions to automatically summarize and plot certain returned data. Lastly, we’ll write up a document via quarto to describe our thought process and give examples of using the functions."
  },
  {
    "objectID": "project_1_558.html#required-packages",
    "href": "project_1_558.html#required-packages",
    "title": "ST 558 Project One",
    "section": "Required Packages",
    "text": "Required Packages\nLoad required packages for project\n\nlibrary(tidyverse)\nlibrary(httr)\nlibrary(jsonlite)\nlibrary(janitor)\nlibrary(quantreg)\nlibrary(roxygen2)"
  },
  {
    "objectID": "project_1_558.html#data-processing",
    "href": "project_1_558.html#data-processing",
    "title": "ST 558 Project One",
    "section": "Data Processing",
    "text": "Data Processing\nsome placeholder text\n\nPrepare Time Variables\nCreate median time table for JWAP and JWDP\nFirst, create JWAP table\n\nURL_jwap &lt;- \"https://api.census.gov/data/2022/acs/acs1/pums/variables/JWAP.json\"\njwap_time_table &lt;- GET(URL_jwap)\n\njwap_time_table &lt;- fromJSON(rawToChar(jwap_time_table$content))\njwap_time_table &lt;- as_tibble(jwap_time_table$values$item)\njwap_time_table &lt;- pivot_longer(jwap_time_table,\n                         cols = 1:ncol(jwap_time_table),\n                         names_to = \"code\",\n                         values_to = \"range\") |&gt;\n  filter(code != 0) |&gt;\n  separate_wider_delim(range, delim = \" \", names = c(\"time1\", \"AMPM1\", \"to\", \"time2\", \"AMPM2\")) \n\njwap_time_table &lt;- jwap_time_table |&gt;\n  mutate(median_time = if_else(\n    AMPM1 == \"a.m.\",\n    hms::as_hms(\n    hms::parse_hm(jwap_time_table$time1) +\n      ((hms::parse_hm(jwap_time_table$time2) -\n          hms::parse_hm(jwap_time_table$time1)) / 2)),\n     hms::as_hms(hms::parse_hm(\"12:00\") +\n                   hms::parse_hm(jwap_time_table$time1) +\n                   ((hms::parse_hm(jwap_time_table$time2) -\n                       hms::parse_hm(jwap_time_table$time1)) / 2)))) |&gt;\n  mutate(median_time = if_else(median_time &gt; hms::as_hms(\"12:00:00\") &\n                                 median_time &lt; hms::as_hms(\"12:59:59\") &\n                                 AMPM1 == \"a.m.\",\n                               median_time - hms::as_hms(\"12:00:00\"),\n                               median_time)) |&gt;\n  select(code, median_time) |&gt;\n  arrange(median_time) |&gt;\n  add_row(code = \"0\", median_time = hms::as_hms(NA))\n\njwap_time_table$code &lt;- as.numeric(jwap_time_table$code)\n\njwap_time_table\n\n# A tibble: 286 × 2\n    code median_time\n   &lt;dbl&gt; &lt;time&gt;     \n 1     1 02'00\"     \n 2     2 07'00\"     \n 3     3 12'00\"     \n 4     4 17'00\"     \n 5     5 22'00\"     \n 6     6 27'00\"     \n 7     7 34'30\"     \n 8     8 42'00\"     \n 9     9 47'00\"     \n10    10 54'30\"     \n# ℹ 276 more rows\n\n\nSecond, create JWDP table\n\nURL_jwdp &lt;- \"https://api.census.gov/data/2022/acs/acs1/pums/variables/JWDP.json\"\njwdp_time_table &lt;- GET(URL_jwdp)\n\njwdp_time_table &lt;- fromJSON(rawToChar(jwdp_time_table$content))\njwdp_time_table &lt;- as_tibble(jwdp_time_table$values$item)\njwdp_time_table &lt;- pivot_longer(jwdp_time_table,\n                         cols = 1:ncol(jwdp_time_table),\n                         names_to = \"code\",\n                         values_to = \"range\") |&gt;\n  filter(code != 0) |&gt;\n  separate_wider_delim(range, delim = \" \", names = c(\"time1\", \"AMPM1\", \"to\", \"time2\", \"AMPM2\")) \n\njwdp_time_table &lt;- jwdp_time_table |&gt;\n  mutate(median_time = if_else(\n    AMPM1 == \"a.m.\",\n    hms::as_hms(\n    hms::parse_hm(jwdp_time_table$time1) +\n      ((hms::parse_hm(jwdp_time_table$time2) -\n          hms::parse_hm(jwdp_time_table$time1)) / 2)),\n     hms::as_hms(hms::parse_hm(\"12:00\") +\n                   hms::parse_hm(jwdp_time_table$time1) +\n                   ((hms::parse_hm(jwdp_time_table$time2) -\n                       hms::parse_hm(jwdp_time_table$time1)) / 2)))) |&gt;\n  mutate(median_time = if_else(median_time &gt; hms::as_hms(\"12:00:00\") &\n                                 median_time &lt; hms::as_hms(\"12:59:59\") &\n                                 AMPM1 == \"a.m.\",\n                               median_time - hms::as_hms(\"12:00:00\"),\n                               median_time)) |&gt;\n  select(code, median_time) |&gt;\n  arrange(median_time) |&gt;\n  add_row(code = \"0\", median_time = hms::as_hms(NA))\n\njwdp_time_table$code &lt;- as.numeric(jwdp_time_table$code)\n\njwdp_time_table\n\n# A tibble: 151 × 2\n    code median_time\n   &lt;dbl&gt; &lt;time&gt;     \n 1     1 00:14:30   \n 2     2 00:44:30   \n 3     3 01:14:30   \n 4     4 01:44:30   \n 5     5 02:14:30   \n 6     6 02:44:30   \n 7     7 03:04:30   \n 8     8 03:14:30   \n 9     9 03:24:30   \n10    10 03:34:30   \n# ℹ 141 more rows\n\n\n\n\nCreate the API\nCreating the API function\n\n#' setup global variables to be returned\n#' @noRd\n\ncensus_tib &lt;- as_tibble(data.frame())\nnum_var &lt;- \"\"\ncat_var &lt;- \"\"\n\nvalid_num_var &lt;- c(\"AGEP\", \"GASP\", \"GRPIP\", \"JWAP\", \"JWDP\", \"JWMNP\", \"PWGTP\")\nvalid_date_var &lt;- c(\"JWAP\", \"JWDP\")\nvalid_cat_var &lt;- c(\"FER\", \"HHL\", \"HISPEED\", \"JWTRNS\", \"SCH\", \"SCHL\", \"SEX\")\nvalid_geo_level &lt;- c(\"ALL\", \"REGION\", \"DIVISION\", \"STATE\")\n\n#' Begin query building\n#' Numeric variable PWGTP is required for function and always called so is not included as a default that can be overwritten\n#' @noRd\n\n\napi_query &lt;- function(surv_year = \"2022\", num_var = c(\"AGEP\", \"PWGTP\"), cat_var = \"SEX\", geo_level = \"ALL\", condition = NULL, geo_subset = \"STATE:11\") {\n  \n\n  #ensure user selection is within permissible values\n  \n  if (surv_year &lt; 2010 || surv_year &gt; 2022) {\n    stop(\"Year must be between 2010 and 2022.\")\n    }\n  if (any(!num_var %in% valid_num_var)) {\n    stop(\"Invalid Numeric Variable\")\n    }\n  if (any(!cat_var %in% valid_cat_var)) {\n    stop(\"Invalid Categorical Variable\")\n    }\n  if (any(!geo_level %in% valid_geo_level)) {\n    print(geo_level)\n    stop(\"Invalid Geography Level\")\n    }\n  \n  \n  #output usable strings for the numerical, categorical, and geo level variables\n  num_var_string &lt;- paste(unique(num_var), collapse = \",\")\n  cat_var_string &lt;- paste(unique(cat_var), collapse = \",\")\n  \n  if (!geo_level == \"ALL\") {\n    geo_level_string &lt;- paste(unique(geo_level), collapse = \",\")\n    }\n  else {\n    geo_level_string = NULL\n    }\n  \n  URL_base &lt;- \"https://api.census.gov/data/\"\n  URL_id &lt;- paste0(URL_base, surv_year, \"/acs/acs1/pums?get=PWGTP,\", num_var_string, \",\", cat_var_string, \",\",geo_level_string)\n  \n  if (!is.null(condition)) {\n    condition_string &lt;- paste(condition, collapse = \"&\")\n    URL_id &lt;- paste0(URL_id, \"&\", condition_string)\n    }\n  \n  if (!is.null(geo_subset)) {\n    region_string &lt;- paste(geo_subset, collapse = \"&\")\n    URL_id &lt;- paste0(URL_id, \"&for=\", region_string)\n    }\n  \n  parsed_url &lt;- parse_url(URL_id)\n  parsed_url$query$get &lt;- paste(unique(unlist(strsplit(parsed_url$query$get, \",\")))[!unique(unlist(strsplit(parsed_url$query$get, \",\"))) %in% names(parsed_url$query)], collapse = \",\")\n  URL_id &lt;- gsub(\"%2C\", \",\", build_url(parsed_url))\n  \n  print(URL_id)\n  \n  census_info &lt;- GET(URL_id)\n  census_df &lt;- fromJSON(rawToChar(census_info$content))\n  \n  census_tib &lt;- census_df |&gt;\n    as_tibble() |&gt;\n    row_to_names(row_number = 1)\n  \n  for (column in colnames(census_tib)) {\n    if (column %in% valid_date_var) {\n      census_tib[[column]] &lt;- as.numeric(census_tib[[column]])\n      } else if (column %in% valid_num_var) {\n        census_tib[[column]] &lt;- as.numeric(census_tib[[column]])\n        } else if (column %in% valid_cat_var) {\n          census_tib[[column]] &lt;- as.factor(census_tib[[column]])\n        }\n    }\n  \n  if(str_detect(URL_id,\"JWAP\")) {\n    census_tib &lt;- census_tib |&gt;\n      left_join(\n        jwap_time_table,\n        by = c(\"JWAP\" = \"code\")\n        ) |&gt;\n      select(-JWAP) |&gt;\n      rename(JWAP = median_time)\n    }\n  \n  if(str_detect(URL_id,\"JWDP\")) {\n    census_tib &lt;- census_tib |&gt;\n      left_join(\n        jwap_time_table,\n        by = c(\"JWDP\" = \"code\")\n        ) |&gt;\n      select(-JWDP) |&gt;\n      rename(JWDP = median_time)\n    }\n  \n  #' Function for creating data assigns a class of census to resulting tibble\n  #' @noRd\n  \n  class(census_tib) &lt;- c(\"census\", class(census_tib))\n  \n  #' Ensure resulting tibble (census_tib) and selected variables are returned to the global environment for use in other functions and analysis\n  #' Superassigmment operator (&lt;&lt;-) is intentional to ensure local variables are passed to the global environment\n  #' A list including num_var, cat_var and census_tib is returned for redudancy and convenience so user assign function to an object and then specify the corresponding version of the variable created\n  #' @noRd\n  \n  num_var &lt;&lt;- num_var\n  cat_var &lt;&lt;- cat_var\n  census_tib &lt;&lt;- census_tib\n  \n  print(census_tib)\n  \n    return(list(\n    num_var = num_var,\n    cat_var = cat_var,\n    census_tib = census_tib\n    ))\n  \n}\n\n\nmulti_api &lt;- function(surv_years, ...) {\n  multi_tibs &lt;- lapply(surv_years, function(surv_year) {\n    api_query(surv_year = surv_year, ...)\n    })\n}\n\n\n\nTest the API Function\n\napi_query(2016, num_var = c(\"GASP\", \"GRPIP\", \"JWAP\"), \"FER\")\n\n[1] \"https://api.census.gov/data/2016/acs/acs1/pums?get=PWGTP,GASP,GRPIP,JWAP,FER&for=STATE%3A11\"\n\n\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nℹ Using compatibility `.name_repair`.\n\n\n# A tibble: 6,646 × 6\n   PWGTP  GASP GRPIP FER   state JWAP  \n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; &lt;time&gt;\n 1   230     3    60 2     11    08:17 \n 2   105    30     0 0     11    24:47 \n 3   119    30     0 2     11    09:17 \n 4   163    80   101 0     11       NA \n 5   132     1     0 0     11    06:22 \n 6    99     0     0 0     11       NA \n 7    34     0     0 0     11       NA \n 8   123   140     0 0     11       NA \n 9   190   140     0 0     11    09:02 \n10    28   380     0 0     11       NA \n# ℹ 6,636 more rows\n\n\n$num_var\n[1] \"GASP\"  \"GRPIP\" \"JWAP\" \n\n$cat_var\n[1] \"FER\"\n\n$census_tib\n# A tibble: 6,646 × 6\n   PWGTP  GASP GRPIP FER   state JWAP  \n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; &lt;time&gt;\n 1   230     3    60 2     11    08:17 \n 2   105    30     0 0     11    24:47 \n 3   119    30     0 2     11    09:17 \n 4   163    80   101 0     11       NA \n 5   132     1     0 0     11    06:22 \n 6    99     0     0 0     11       NA \n 7    34     0     0 0     11       NA \n 8   123   140     0 0     11       NA \n 9   190   140     0 0     11    09:02 \n10    28   380     0 0     11       NA \n# ℹ 6,636 more rows\n\n\nFinal run to reflect assigned `state`: 11 / DC\n\ndefault_query &lt;- api_query()\n\n[1] \"https://api.census.gov/data/2022/acs/acs1/pums?get=PWGTP,AGEP,SEX&for=STATE%3A11\"\n# A tibble: 6,718 × 4\n   PWGTP  AGEP SEX   state\n   &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt;\n 1    81    18 2     11   \n 2    67    18 2     11   \n 3    85    19 1     11   \n 4    51    18 1     11   \n 5    56    23 2     11   \n 6    80    20 1     11   \n 7   213    34 2     11   \n 8   175    66 1     11   \n 9    84    24 1     11   \n10    62    19 2     11   \n# ℹ 6,708 more rows\n\ndefault_query\n\n$num_var\n[1] \"AGEP\"  \"PWGTP\"\n\n$cat_var\n[1] \"SEX\"\n\n$census_tib\n# A tibble: 6,718 × 4\n   PWGTP  AGEP SEX   state\n   &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt;\n 1    81    18 2     11   \n 2    67    18 2     11   \n 3    85    19 1     11   \n 4    51    18 1     11   \n 5    56    23 2     11   \n 6    80    20 1     11   \n 7   213    34 2     11   \n 8   175    66 1     11   \n 9    84    24 1     11   \n10    62    19 2     11   \n# ℹ 6,708 more rows"
  },
  {
    "objectID": "project_1_558.html#writing-a-generic-function-for-summarizing",
    "href": "project_1_558.html#writing-a-generic-function-for-summarizing",
    "title": "ST 558 Project One",
    "section": "Writing a Generic Function for Summarizing",
    "text": "Writing a Generic Function for Summarizing\nsome placeholder text\n\nNumeric Summary\nwrite a function that produces means and standard deviations for our numeric variable(s) and counts for our categorical variable(s).\n\ncensus_summary &lt;- function(tib = census_tib, cat_var_s, num_var_s) {\n  \n  for(name in num_var_s) {\n    if(name %in% colnames(tib) &\n       name %in% valid_num_var &\n       name != \"PWGTP\") {\n      sample_mean &lt;- sum(tib[[name]] * tib$PWGTP)/sum(tib$PWGTP)\n      sample_sd &lt;- sqrt(sum((tib[[name]]^2)*tib$PWGTP)/sum(tib$PWGTP)-sample_mean^2)\n    } else {\n        stop(\"Please enter numeric variables used in API call\")\n      }\n  }\n  \n  for(name in cat_var_s) {\n    if(name %in% colnames(tib) &\n       name %in% valid_cat_var) {\n      counts &lt;- tib |&gt;\n        group_by(tib[[name]]) |&gt;\n        summarise(count = n())\n    } else {\n        stop(\"Please enter categorical variables used in API call\")\n      }\n  } \n  \n  return(list(sample_mean = sample_mean, sample_sd = sample_sd, counts = counts))\n}\n\nTest out this function by running summary(your_census_tibble) on something you’ve returned from your census API function.\n\ncen_sum &lt;- census_summary(cat_var_s = \"SEX\", num_var_s = \"AGEP\")\nprint(cen_sum)\n\n$sample_mean\n[1] 37.05794\n\n$sample_sd\n[1] 21.39444\n\n$counts\n# A tibble: 2 × 2\n  `tib[[name]]` count\n  &lt;fct&gt;         &lt;int&gt;\n1 1              3135\n2 2              3583\n\n\n\n\nGraphical Summary\nSimilarly, let’s create a generic plot() function for a census class tibble. Require the user to specify one categorical variable and one numeric variable for plotting purposes.\n\ncensus_plot &lt;- function(tib = census_tib, cat_var_s, num_var_s) {\n  \n  for(name in num_var_s) {\n    if(name %in% colnames(tib) &\n       name %in% valid_num_var &\n       name != \"PWGTP\") {\n      y &lt;- tib[[name]]\n    } else {\n        stop(\"Please enter numeric variables used in API call\")\n      }\n  }\n  \n  for(name in cat_var_s) {\n    if(name %in% colnames(tib) &\n       name %in% valid_cat_var) {\n      x &lt;- tib[[name]]\n    } else {\n        stop(\"Please enter categorical variables used in API call\")\n      }\n  } \n  \n  ggplot(tib,\n       aes(x = x, y = y, weight = PWGTP)) +\n    geom_boxplot() +\n    xlab(cat_var_s) +\n    ylab(num_var_s)\n}\n\nTest `census_plot` function\n\ncensus_plot(cat_var_s = \"SEX\", num_var_s = \"AGEP\")\n\nWarning in rq.fit.br(wx, wy, tau = tau, ...): Solution may be nonunique"
  }
]