[
  {
    "objectID": "project_1_558.html",
    "href": "project_1_558.html",
    "title": "ST 558 Project One",
    "section": "",
    "text": "Our goal is to write functions that will manipulate and process data sets that come from a census API. We will query the Public Use Microdata Sample (PUMS) Census API, creating a function that allows the user to call the API with different combinations of variables. We’ll then create generic functions to automatically summarize and plot certain returned data, providing numerical and graphical summaries. Lastly, we’ll write up this document via quarto to describe our thought process and give examples of using the functions."
  },
  {
    "objectID": "project_1_558.html#project-overview",
    "href": "project_1_558.html#project-overview",
    "title": "ST 558 Project One",
    "section": "",
    "text": "Our goal is to write functions that will manipulate and process data sets that come from a census API. We will query the Public Use Microdata Sample (PUMS) Census API, creating a function that allows the user to call the API with different combinations of variables. We’ll then create generic functions to automatically summarize and plot certain returned data, providing numerical and graphical summaries. Lastly, we’ll write up this document via quarto to describe our thought process and give examples of using the functions."
  },
  {
    "objectID": "project_1_558.html#required-packages",
    "href": "project_1_558.html#required-packages",
    "title": "ST 558 Project One",
    "section": "Required Packages",
    "text": "Required Packages\nLoad required packages for project.\n\nlibrary(tidyverse)\nlibrary(httr)\nlibrary(jsonlite)\nlibrary(janitor)\nlibrary(quantreg)\nlibrary(roxygen2)"
  },
  {
    "objectID": "project_1_558.html#data-processing",
    "href": "project_1_558.html#data-processing",
    "title": "ST 558 Project One",
    "section": "Data Processing",
    "text": "Data Processing\nBefore creating a function with the API, we first had to validate the integrity of variables. Considering that we have both numerical and categorical variables, we decided to look through each and account for the factors and numerical ranges as appropriate. After validating the variables, we created the API. The API is created so that it prints out the requested categorical, numerical, and time variables with conditions and geographical subset. The user has free rein to choose one or multiple of each type of variable, and if a user would like to select multiple years of data, the multi_api function allows them to do so.\n\nPrepare Time Variables\nThe time variables need to be handled slightly differently than the other numeric variables. Since there are NA’s, and also since we are working with a range of values, we have decided to find the median (or exact middle) of each time to use for JWAP and JWDP. In particular, JWAP is the time of arrival at work by hour and minute, and JWDP is the time of departure for work by hour and minute. Before we run the API function, we first decided to create a median time table for JWAP and JWDP.\nFirst, create JWAP table:\n\nURL_jwap &lt;- \"https://api.census.gov/data/2022/acs/acs1/pums/variables/JWAP.json\"\njwap_time_table &lt;- GET(URL_jwap)\n\njwap_time_table &lt;- fromJSON(rawToChar(jwap_time_table$content))\njwap_time_table &lt;- as_tibble(jwap_time_table$values$item)\njwap_time_table &lt;- pivot_longer(jwap_time_table,\n                         cols = 1:ncol(jwap_time_table),\n                         names_to = \"code\",\n                         values_to = \"range\") |&gt;\n  filter(code != 0) |&gt;\n  separate_wider_delim(range, delim = \" \", names = c(\"time1\", \"AMPM1\", \"to\", \"time2\", \"AMPM2\")) \n\njwap_time_table &lt;- jwap_time_table |&gt;\n  mutate(median_time = if_else(\n    AMPM1 == \"a.m.\",\n    hms::as_hms(\n    hms::parse_hm(jwap_time_table$time1) +\n      ((hms::parse_hm(jwap_time_table$time2) -\n          hms::parse_hm(jwap_time_table$time1)) / 2)),\n     hms::as_hms(hms::parse_hm(\"12:00\") +\n                   hms::parse_hm(jwap_time_table$time1) +\n                   ((hms::parse_hm(jwap_time_table$time2) -\n                       hms::parse_hm(jwap_time_table$time1)) / 2)))) |&gt;\n  mutate(median_time = if_else(median_time &gt; hms::as_hms(\"12:00:00\") &\n                                 median_time &lt; hms::as_hms(\"12:59:59\") &\n                                 AMPM1 == \"a.m.\",\n                               median_time - hms::as_hms(\"12:00:00\"),\n                               median_time)) |&gt;\n  select(code, median_time) |&gt;\n  arrange(median_time) |&gt;\n  add_row(code = \"0\", median_time = hms::as_hms(NA))\n\njwap_time_table$code &lt;- as.numeric(jwap_time_table$code)\n\njwap_time_table\n\n# A tibble: 286 × 2\n    code median_time\n   &lt;dbl&gt; &lt;time&gt;     \n 1     1 02'00\"     \n 2     2 07'00\"     \n 3     3 12'00\"     \n 4     4 17'00\"     \n 5     5 22'00\"     \n 6     6 27'00\"     \n 7     7 34'30\"     \n 8     8 42'00\"     \n 9     9 47'00\"     \n10    10 54'30\"     \n# ℹ 276 more rows\n\n\nSecond, create JWDP table:\n\nURL_jwdp &lt;- \"https://api.census.gov/data/2022/acs/acs1/pums/variables/JWDP.json\"\njwdp_time_table &lt;- GET(URL_jwdp)\n\njwdp_time_table &lt;- fromJSON(rawToChar(jwdp_time_table$content))\njwdp_time_table &lt;- as_tibble(jwdp_time_table$values$item)\njwdp_time_table &lt;- pivot_longer(jwdp_time_table,\n                         cols = 1:ncol(jwdp_time_table),\n                         names_to = \"code\",\n                         values_to = \"range\") |&gt;\n  filter(code != 0) |&gt;\n  separate_wider_delim(range, delim = \" \", names = c(\"time1\", \"AMPM1\", \"to\", \"time2\", \"AMPM2\")) \n\njwdp_time_table &lt;- jwdp_time_table |&gt;\n  mutate(median_time = if_else(\n    AMPM1 == \"a.m.\",\n    hms::as_hms(\n    hms::parse_hm(jwdp_time_table$time1) +\n      ((hms::parse_hm(jwdp_time_table$time2) -\n          hms::parse_hm(jwdp_time_table$time1)) / 2)),\n     hms::as_hms(hms::parse_hm(\"12:00\") +\n                   hms::parse_hm(jwdp_time_table$time1) +\n                   ((hms::parse_hm(jwdp_time_table$time2) -\n                       hms::parse_hm(jwdp_time_table$time1)) / 2)))) |&gt;\n  mutate(median_time = if_else(median_time &gt; hms::as_hms(\"12:00:00\") &\n                                 median_time &lt; hms::as_hms(\"12:59:59\") &\n                                 AMPM1 == \"a.m.\",\n                               median_time - hms::as_hms(\"12:00:00\"),\n                               median_time)) |&gt;\n  select(code, median_time) |&gt;\n  arrange(median_time) |&gt;\n  add_row(code = \"0\", median_time = hms::as_hms(NA))\n\njwdp_time_table$code &lt;- as.numeric(jwdp_time_table$code)\n\njwdp_time_table\n\n# A tibble: 151 × 2\n    code median_time\n   &lt;dbl&gt; &lt;time&gt;     \n 1     1 00:14:30   \n 2     2 00:44:30   \n 3     3 01:14:30   \n 4     4 01:44:30   \n 5     5 02:14:30   \n 6     6 02:44:30   \n 7     7 03:04:30   \n 8     8 03:14:30   \n 9     9 03:24:30   \n10    10 03:34:30   \n# ℹ 141 more rows\n\n\nNow that this is complete, we can finish Data Processing by creating the API.\n\n\nCreate the API\nThe API starts by creating blank variables so that a clean slate is run each time. Then, global valid variables of each possible user selection (numerical, categorical, date, and geographical level) are listed for use in the API and later functions. Specific decisions are outlined in documentation and comments within the function.\nFirst, global variables are initialized and valid inputs are established.\n\n#' setup global variables to be returned\n#' @noRd\n\n#blank variables for clean slate\ncensus_tib &lt;- as_tibble(data.frame())\nnum_var &lt;- \"\"\ncat_var &lt;- \"\"\n\n#all possible variable values\nvalid_num_var &lt;- c(\"AGEP\", \"GASP\", \"GRPIP\", \"JWAP\", \"JWDP\", \"JWMNP\", \"PWGTP\")\nvalid_date_var &lt;- c(\"JWAP\", \"JWDP\")\nvalid_cat_var &lt;- c(\"FER\", \"HHL\", \"HISPEED\", \"JWTRNS\", \"SCH\", \"SCHL\", \"SEX\")\nvalid_geo_level &lt;- c(\"ALL\", \"REGION\", \"DIVISION\", \"STATE\")\n\nThen, a helper function is created:\n\nget_url &lt;- function(URL_id) {\n  census_info &lt;- GET(URL_id)\n  census_df &lt;- fromJSON(rawToChar(census_info$content))\n  \n  #create a tibble \n  census_tib &lt;- census_df |&gt;\n    as_tibble() |&gt;\n    row_to_names(row_number = 1)\n  return(census_tib)\n}\n\n\n#' Begin query building\n#' Numeric variable PWGTP is required for function and always called so is not included as a default that can be overwritten\n#' @noRd\n\napi_query &lt;- function(surv_year = \"2022\", num_var = c(\"AGEP\", \"PWGTP\"), cat_var = \"SEX\", geo_level = \"ALL\", condition = NULL, geo_subset = \"STATE:11\") {\n  \n\n  #ensure user selection is within permissible values\n  \n  if (surv_year &lt; 2010 || surv_year &gt; 2022 || surv_year == 2020) {\n    stop(\"Year must be between 2010 and 2022, excluding 2020.\")\n    }\n  if (any(!num_var %in% valid_num_var)) {\n    stop(\"Invalid Numeric Variable\")\n    }\n  if (any(!cat_var %in% valid_cat_var)) {\n    stop(\"Invalid Categorical Variable\")\n    }\n  if (any(!geo_level %in% valid_geo_level)) {\n    print(geo_level)\n    stop(\"Invalid Geography Level\")\n    }\n  \n  \n  #output unique usable strings for the numerical, categorical, and geo level variables\n  num_var_string &lt;- paste(unique(num_var), collapse = \",\")\n  cat_var_string &lt;- paste(unique(cat_var), collapse = \",\")\n  \n  #if geo level is all, then don't do anything, else then start it as null to be replaced\n  \n  if (!geo_level == \"ALL\") {\n    geo_level_string &lt;- paste(unique(geo_level), collapse = \",\")\n    }\n  else {\n    geo_level_string = NULL\n    }\n  \n  #start with the URl base, and then append the required numerical, categorical, and geo level with the designated survey years\n  URL_base &lt;- \"https://api.census.gov/data/\"\n  URL_id &lt;- paste0(URL_base, surv_year, \"/acs/acs1/pums?get=PWGTP,\", num_var_string, \",\", cat_var_string, \",\",geo_level_string)\n  \n  #make room for conditions, including subsetting by cat/num and also by region\n  \n  if (!is.null(condition)) {\n    condition_string &lt;- paste(condition, collapse = \"&\")\n    URL_id &lt;- paste0(URL_id, \"&\", condition_string)\n    }\n  \n  if (!is.null(geo_subset)) {\n    region_string &lt;- paste(geo_subset, collapse = \"&\")\n    URL_id &lt;- paste0(URL_id, \"&for=\", region_string)\n    }\n  \n  #allow user to see their finalized url, then parse it for parameters\n  print(URL_id)\n  parsed_url &lt;- parse_url(URL_id)\n  \n  #pipe to fix spacing and commas, otherwise error\n  parsed_url$query$get &lt;- parsed_url$query$get |&gt;\n  strsplit(split = \",\") |&gt;\n  unlist() |&gt;\n  unique() |&gt;\n  setdiff(names(parsed_url$query)) |&gt;\n  paste(collapse = \",\")\n  \n  #clean up url\n  URL_id &lt;- gsub(\"%2C\", \",\", build_url(parsed_url))\n  \n  #print(URL_id)\n  \n  #query the api now via a helper function\n  #GET(URL_id)\n  census_info &lt;- GET(URL_id)\n  census_df &lt;- fromJSON(rawToChar(census_info$content))\n\n  #create a tibble\n  census_tib &lt;- census_df |&gt;\n    as_tibble() |&gt;\n    row_to_names(row_number = 1)\n  \n  #append columns to the tibble based on the selected variables from before\n  for (column in colnames(census_tib)) {\n    if (column %in% valid_date_var) {\n      census_tib[[column]] &lt;- as.numeric(census_tib[[column]])\n      } else if (column %in% valid_num_var) {\n        census_tib[[column]] &lt;- as.numeric(census_tib[[column]])\n        } else if (column %in% valid_cat_var) {\n          census_tib[[column]] &lt;- as.factor(census_tib[[column]])\n        }\n    }\n  \n  #create statements for the time variables that formats them based on the definitions from up above if they are present.\n  if(str_detect(URL_id,\"JWAP\")) {\n    census_tib &lt;- census_tib |&gt;\n      left_join(\n        jwap_time_table,\n        by = c(\"JWAP\" = \"code\")\n        ) |&gt;\n      select(-JWAP) |&gt;\n      rename(JWAP = median_time)\n    }\n  \n  if(str_detect(URL_id,\"JWDP\")) {\n    census_tib &lt;- census_tib |&gt;\n      left_join(\n        jwap_time_table,\n        by = c(\"JWDP\" = \"code\")\n        ) |&gt;\n      select(-JWDP) |&gt;\n      rename(JWDP = median_time)\n    }\n  \n  if(str_detect(URL_id,\"SEX\")) {\n    census_tib &lt;- census_tib |&gt;\n      mutate(SEX = factor(SEX, labels = c(\"Male\", \"Female\")))\n    }\n  \n  if(str_detect(URL_id,\"FER\")) {\n    census_tib &lt;- census_tib |&gt;\n      mutate(FER = factor(FER, labels = c(\"NA\", \"Yes\", \"No\")))\n    }\n  \n  if(str_detect(URL_id,\"HHL\")) {\n    census_tib &lt;- census_tib |&gt;\n      mutate(HHL = factor(HHL, labels = c(\"NA\",\n                                          \"English\",\n                                          \"Spanish\",\n                                          \"Other Indo-European\",\n                                          \"Asian or Pacfic Island\",\n                                          \"Other\")))\n    }\n  \n  #' Function for creating data assigns a class of census to resulting tibble\n  #' @noRd\n  \n  class(census_tib) &lt;- c(\"census\", class(census_tib))\n  \n  #' Ensure resulting tibble (census_tib) and selected variables are returned to the global environment for use in other functions and analysis\n  #' Superassigmment operator (&lt;&lt;-) is intentional to ensure local variables are passed to the global environment\n  #' A list including num_var, cat_var and census_tib is returned for redudancy and convenience so user assign function to an object and then specify the corresponding version of the variable created\n  #' @noRd\n  \n  num_var &lt;&lt;- num_var\n  cat_var &lt;&lt;- cat_var\n  census_tib &lt;&lt;- census_tib\n  \n  \n  return(list(\n  num_var = num_var,\n  cat_var = cat_var,\n  census_tib = census_tib\n  ))\n  \n}\n\n\n\nMulti-Year API\nThis function takes the api_query function and allows the user, along with the previous defaults from that function, to select multiple years and return one large tibble that binds the multiple years by row.\n\nmulti_api &lt;- function(surv_years, ...) {\n  multi_tibs &lt;- lapply(surv_years, function(surv_year) {\n    tib_call &lt;- api_query(surv_year = surv_year, ...)\n    final_tib &lt;- tib_call$census_tib\n    final_tib &lt;- final_tib  |&gt; \n      mutate(surv_year = surv_year)\n    return(final_tib)\n    })\n  entire_tib &lt;- bind_rows(multi_tibs)\n  return(entire_tib)\n}\n\n\n\nTest the API Function\nEnsure the api_query function is working properly by feeding in some numeric, date, and categorical variables.\n\napi_query(2016, num_var = c(\"GASP\", \"GRPIP\", \"JWAP\"), \"FER\")\n\n[1] \"https://api.census.gov/data/2016/acs/acs1/pums?get=PWGTP,GASP,GRPIP,JWAP,FER,&for=STATE:11\"\n\n\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nℹ Using compatibility `.name_repair`.\n\n\n$num_var\n[1] \"GASP\"  \"GRPIP\" \"JWAP\" \n\n$cat_var\n[1] \"FER\"\n\n$census_tib\n# A tibble: 6,646 × 6\n   PWGTP  GASP GRPIP FER   state JWAP  \n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; &lt;time&gt;\n 1   104     3     0 NA    11       NA \n 2   115     3     0 NA    11    24:02 \n 3    86     3     0 NA    11    08:37 \n 4   109     3     0 NA    11       NA \n 5    54     1     0 NA    11    08:17 \n 6    37     1     0 No    11    15:27 \n 7    51    50     0 NA    11       NA \n 8   113    50     0 NA    11       NA \n 9   346     1    15 No    11    08:37 \n10   131     1    21 No    11    08:47 \n# ℹ 6,636 more rows\n\n\nEnsure the multi_api function is working properly by combining years and feeding in some numeric, date, and categorical variables.\n\nmulti_api(surv_years = c(\"2015\", \"2021\"), num_var = c(\"JWDP\",\"GRPIP\",\"GRPIP\"), cat_var = c(\"FER\", \"HHL\"), condition=\"AGEP=30\", geo_subset= \"STATE:19\")\n\n[1] \"https://api.census.gov/data/2015/acs/acs1/pums?get=PWGTP,JWDP,GRPIP,FER,HHL,&AGEP=30&for=STATE:19\"\n[1] \"https://api.census.gov/data/2021/acs/acs1/pums?get=PWGTP,JWDP,GRPIP,FER,HHL,&AGEP=30&for=STATE:19\"\n\n\n# A tibble: 723 × 8\n   PWGTP GRPIP FER   HHL      AGEP state JWDP   surv_year\n   &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;time&gt; &lt;chr&gt;    \n 1    35     0 NA    English    30 19    04:17  2015     \n 2    51     0 No    English    30 19    04:17  2015     \n 3    57     0 No    English    30 19    11:22  2015     \n 4    82     0 No    English    30 19       NA  2015     \n 5   220     0 No    English    30 19    04:37  2015     \n 6    52    11 No    English    30 19    09:47  2015     \n 7    75    76 Yes   English    30 19    03:17  2015     \n 8    96     0 No    English    30 19    03:52  2015     \n 9    59     0 NA    English    30 19    03:32  2015     \n10   174     0 NA    English    30 19    01:42  2015     \n# ℹ 713 more rows\n\n\nFinally, test the empty function call (i.e., test the default query) to reflect assigned `state` of 11 (i.e., DC). This is the tibble to be used in creating summaries below.\n\ndefault_query &lt;- api_query()\n\n[1] \"https://api.census.gov/data/2022/acs/acs1/pums?get=PWGTP,AGEP,PWGTP,SEX,&for=STATE:11\"\n\ndefault_query\n\n$num_var\n[1] \"AGEP\"  \"PWGTP\"\n\n$cat_var\n[1] \"SEX\"\n\n$census_tib\n# A tibble: 6,718 × 4\n   PWGTP  AGEP SEX    state\n   &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;  &lt;chr&gt;\n 1    81    18 Female 11   \n 2    67    18 Female 11   \n 3    85    19 Male   11   \n 4    51    18 Male   11   \n 5    56    23 Female 11   \n 6    80    20 Male   11   \n 7   213    34 Female 11   \n 8   175    66 Male   11   \n 9    84    24 Male   11   \n10    62    19 Female 11   \n# ℹ 6,708 more rows"
  },
  {
    "objectID": "project_1_558.html#writing-a-generic-function-for-summarizing",
    "href": "project_1_558.html#writing-a-generic-function-for-summarizing",
    "title": "ST 558 Project One",
    "section": "Writing a Generic Function for Summarizing",
    "text": "Writing a Generic Function for Summarizing\nFor the variables returned from the API call (or some subset thereof), generate specific numeric and graphical summaries to describe the data.\n\nNumeric Summary\nWrite a function that produces means and standard deviations for our numeric variable(s) and counts for our categorical variable(s).\n\ncensus_summary &lt;- function(tib = census_tib, cat_var_s = c(intersect(colnames(census_tib), valid_cat_var)), num_var_s = c(setdiff(intersect(colnames(census_tib), valid_num_var), \"PWGTP\"))) {\n  \n  sample_means &lt;- list()\n  sample_sds &lt;- list()\n  all_counts &lt;- list()\n  \n  for(name in num_var_s) {\n    if(name %in% colnames(tib) &\n       name %in% valid_num_var &\n       !name %in% c(\"PWGTP\", \"JWDP\", \"JWAP\")) {\n      sample_mean &lt;- sum(tib[[name]] * tib$PWGTP)/sum(tib$PWGTP)\n      sample_sd &lt;- sqrt(sum((tib[[name]]^2)*tib$PWGTP)/sum(tib$PWGTP)-sample_mean^2)\n      sample_means[[name]] &lt;- sample_mean\n      sample_sds[[name]] &lt;- sample_sd\n    }\n    else if(name %in% c(\"JWAP\", \"JWDP\")) {\n      tib &lt;- na.omit(tib)\n      sample_mean &lt;- (sum(as.numeric(tib[[name]]) * tib$PWGTP)/sum(tib$PWGTP))\n      sample_sd &lt;- (sqrt(sum((as.numeric(tib[[name]])^2)*tib$PWGTP)/sum(tib$PWGTP)-sample_mean^2))\n      sample_mean &lt;- hms::round_hms(hms::as_hms(sample_mean), secs = 1)\n      sample_sd &lt;- hms::round_hms(hms::as_hms(sample_sd), secs = 1)\n      sample_means[[name]] &lt;- sample_mean\n      sample_sds[[name]] &lt;- sample_sd\n      }\n    else {\n        stop(\"Please enter numeric variables used in API call except PWGTP\")\n    }\n  }\n  \n  for(name in cat_var_s) {\n    if(name %in% colnames(tib) & name %in% valid_cat_var) {\n      counts &lt;- tib |&gt;\n        group_by(tib[[name]]) |&gt;\n        summarise(count = n()) |&gt;\n        rename_with(~ name, 1)\n      all_counts[[name]] &lt;- counts\n    } else {\n        stop(\"Please enter categorical variables used in API call\")\n      }\n  }\n  #return as a named list\n  return(list(sample_means = sample_means, sample_sds = sample_sds, all_counts = all_counts))\n}\n\nTest out this function by running census_summary on SEX and AGEP variables per the default api_query.\n\ncen_sum &lt;- census_summary(cat_var_s = \"SEX\", num_var_s = \"AGEP\")\nprint(cen_sum)\n\n$sample_means\n$sample_means$AGEP\n[1] 37.05794\n\n\n$sample_sds\n$sample_sds$AGEP\n[1] 21.39444\n\n\n$all_counts\n$all_counts$SEX\n# A tibble: 2 × 2\n  SEX    count\n  &lt;fct&gt;  &lt;int&gt;\n1 Male    3135\n2 Female  3583\n\n\nValidate that the call above returns the same output as an empty function call.\n\ndefault_cen_sum &lt;- census_summary()\nprint(default_cen_sum)\n\n$sample_means\n$sample_means$AGEP\n[1] 37.05794\n\n\n$sample_sds\n$sample_sds$AGEP\n[1] 21.39444\n\n\n$all_counts\n$all_counts$SEX\n# A tibble: 2 × 2\n  SEX    count\n  &lt;fct&gt;  &lt;int&gt;\n1 Male    3135\n2 Female  3583\n\n\n\n\nGraphical Summary\nCreate a generic plot() function for a census class tibble. Require the user to specify one categorical variable and one numeric variable for plotting purposes.\n\ncensus_plot &lt;- function(tib = census_tib, cat_var_s, num_var_s) {\n  \n  for(name in num_var_s) {\n    if(name %in% colnames(tib) &\n       name %in% valid_num_var &\n       name != \"PWGTP\") {\n      y &lt;- tib[[name]]\n    } else {\n        stop(\"Please enter numeric variables used in API call\")\n      }\n  }\n  \n  for(name in cat_var_s) {\n    if(name %in% colnames(tib) &\n       name %in% valid_cat_var) {\n      x &lt;- tib[[name]]\n    } else {\n        stop(\"Please enter categorical variables used in API call\")\n      }\n  } \n  \n  ggplot(tib,\n       aes(x = x, y = y, weight = PWGTP)) +\n    geom_boxplot() +\n    xlab(cat_var_s) +\n    ylab(num_var_s)\n}\n\nTest the `census_plot` function on SEX and AGEP variables per the default api_query.\n\ncensus_plot(cat_var_s = \"SEX\", num_var_s = \"AGEP\")"
  }
]